# Exercise 05
## Purpose

* Learn how to use VUnit integer arrays for file-based testing
* Learn how to add pre and post simulation hooks
* Learn how to co-simulate with Matlab/Octave

After this exercise you will be able to use VUnit for file-based verification. You will also know the basics for integrating your simulation with external tools such as Matlab/Octave.

More information on this topic can be found in the [configuration documentation](http://vunit.github.io/py/ui.html#configurations) and in this [LinkedIn article](https://www.linkedin.com/pulse/vunit-matlab-integration-lars-asplund).

## Instructions

* Create a copy of `exercise_05/original` named `exercise_05/workspace`.
* Open `exercise_05/workspace/test/tb_file_based_testing.vhd`. This testbench verifies an incrementer component that takes a stream of 16-bit numbers (`input_tdata`) and a data valid signal (`input_tvalid`) and produces an output stream (`output_tdata`) which is the input + 1 along with an `output_tvalid` signal.

    The first statement of the first test case reads:

    ``` vhdl
    input_data := load_csv(file_name => join(tb_path(runner_cfg), "input_data.csv"),
                           bit_width => input_tdata'length,
                           is_signed => false);
    ```


  `input_data` is a variable of type `integer_array_t` which is a dynamic 1D, 2D, or 3D array of integer data. In this example we have a 1D array, a vector, which we initialize with data from `input_data.csv` located in the same directory as the testbench, `tb_path(runner_cfg)`. `input_data.csv` contains integers which are assumed to be positive (`is_signed => false`) and fit within 16 bits (`bit_width => input_tdata'length`).

  We also load the expected data from file but in this case from a binary file using `load_raw` rather than `load_csv`.

    ``` vhdl
    expected_data := load_raw(file_name => join(tb_path(runner_cfg), "expected_data.dat"),
                              bit_width => output_tdata'length,
                              is_signed => false);
    ```

  We can now loop over our vectors, apply input from the input data vector and verify the output with data from the expected data vector.

    ``` vhdl
    input_tvalid <= '1';
    for i in 0 to length(input_data) - 1 loop
      input_tdata <= to_slv(get(input_data, i), input_tdata);
      wait until falling_edge(clk);
      check_equal(output_tdata, get(expected_data, i), result("for output_tdata"));
      check_equal(output_tvalid, '1', result("for output_tvalid"));
    end loop;
    ```

* Open `exercise_05/workspace/run.py`. Note that the second test case of `test/tb_file_based_testing.vhd` has a configuration added to it:

    ``` python
    tb_lib.test_bench("tb_file_based_testing").test("Test generating and verifying data in hooks").add_config(
        name="hooks demo",
        pre_config=function_running_before_test_case,
        post_check=function_running_after_test_case)
    ```

  This time we're not defining generics for the test case but rather a `pre_config` function, a Python function running before the test case, and a `post_check` function, a Python function running after the test case.

  The `pre_config` function is typically used to generate input data to the simulation, either by itself or by calling some external program. In this case `function_running_before_test_case` will create a file with random input data that will be used by the simulation just like in the first test case.

  The `post_check` function is typically used to verify output data files generated by the simulation. Again, this can be done with the help of an external model, for example a Matlab model, but in this case `function_running_before_test_case` will do the verification by itself.

  If you look at the second test case you'll see that the output of the DUT is appended to an initially empty integer array (`dut_response`) and once all outputs have been collected the contents is saved to file using the `save_csv` function.

    ``` vhdl
    dut_response := new_1d(bit_width => output_tdata'length, is_signed => false);

    input_tvalid <= '1';
    for i in 0 to length(input_data) - 1 loop
      input_tdata <= to_slv(get(input_data, i), input_tdata);
      wait until falling_edge(clk);
      if output_tvalid then
        append(dut_response, to_integer(output_tdata));
      end if;
    end loop;

    save_csv(dut_response, join(output_path(runner_cfg), "dut_response.csv"));
    ```

  Note the last line. In this case we're saving the file to the `output_path` directory rather than `tb_path`. `output_path` is a directory created by VUnit that is unique to your test case. This means that several test cases can generate files with the same name without overwriting each other.

* Run the test cases and note that an output file is listed for every test case (the third test case is failing because we haven't fixed it yet). That file is located in the `output_path` directory. Browse to that directory and you'll find the CSV files produced by the simulation.

* If you look at the top of `exercise_05/workspace/run.py` you'll find the `function_running_before_test_case` and `function_running_after_test_case` functions. The Python code in these functions is beyond the scope of this tutorial but note that
    1. They have an `output_path` argument giving them access to that directory
    2. They would normally return `True` but in the case of an error they will return `False` and cause the test case to fail.
    ``` python
    if got != expected:
        print("Got %s, expected %s" % (str(got), str(expected)))
        return False
    ```

    Remove the line

    ``` vhdl
    input_tvalid <= '1';
    ```

    in the VHDL code above and give it a try!

* The third test case, `Test Matlab/Octave co-simulation`, has hooks calling Matlab/Octave to do the generation of input data and verify the output data. This is done using two M-scripts located in `exercise_05/workspace/octave`. Complete these M-scripts and the `run.py`.
